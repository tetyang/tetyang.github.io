<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>跳表的原理与实现</title>
    <url>/tetyang.github.io/2020/05/24/%E8%B7%B3%E8%A1%A8%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>跳表是一种非常漂亮的数据结构。跳表的基本结构是由一系列单链表（singly-linked lists）$L_0,…L_h$构成的，我们可以把这一系列的单链表看成一种层级结构。$L_0$层有$n$个元素，我们从$L_0$层开始，逐层向上构建，每一层的单链表包含的元素都是前一层元素中随机选取的子集，直到所选取的子集为空为止。一个包含七个元素的跳表可以用下图表示</p>
<p><a href="https://imgchr.com/i/t9Prm6" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t9Prm6.png" alt="t9Prm6.png"></a></p>
<p>在跳表中，我们把有元素(节点）x出现的最高层的层数叫做元素x的高度。例如，只在$L_0$中出现的元素的高度为0。一个跳表的高度是其所包含的高度最高的节点的高度。</p>
<p>跳表的头部是一个特殊节点，叫做哨兵节点(sentinel node),这是一个哑节点(dummy node),对跳表的操作起辅助作用，不储存元素。跳表的关键性质是，从哨兵节点的$L_H$层开始，到$L_0$层的任意元素x，都存在一条最短路径，叫做搜索路径(search path)。下图例示了从哨兵节点的$L_5$层，到$L_0$层包含元素4的节点的搜索路径。</p>
<p><a href="https://imgchr.com/i/t9mzuQ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t9mzuQ.png" alt="t9mzuQ.png"></a></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">T x;</span><br><span class="line">Node&lt;T&gt;[] next;</span><br><span class="line">Node(T ix, <span class="keyword">int</span> h) &#123;</span><br><span class="line">x = ix;</span><br><span class="line">next = Array.newInstance(Node<span class="class">.<span class="keyword">class</span>, <span class="title">h</span>+1)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> next.length - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>跳表</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型实现原理——类型擦除机制解释</title>
    <url>/tetyang.github.io/2020/04/01/Java%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E6%9C%BA%E5%88%B6%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<h1 id="Java泛型的实现原理"><a href="#Java泛型的实现原理" class="headerlink" title="Java泛型的实现原理"></a>Java泛型的实现原理</h1><p>编译器在将泛型的代码转换成虚拟机能识别的字节码时，有两种机制可以选择：<br>1.代码专化（Code specialization）</p>
<blockquote>
<p>balabala </p>
</blockquote>
<p>2.代码共享（Code sharing)</p>
<blockquote>
<p>balabala</p>
</blockquote>
<p>C++的泛型采用了前者，而Java采用了后者，即Java的编译器为每一个泛型类(或方法)提供了唯一的字节码表示，并把该泛型类(或方法)的每一个不同的实例化和这个唯一的字节码表示对应，实现这种对应的机制叫<strong>类型擦除（type erasure）</strong></p>
<h1 id="理解类型擦除"><a href="#理解类型擦除" class="headerlink" title="理解类型擦除"></a>理解类型擦除</h1><h1 id="类型擦除示例"><a href="#类型擦除示例" class="headerlink" title="类型擦除示例"></a>类型擦除示例</h1><p>$sin^2\theta + cos^2\theta = 1$</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>泛型</tag>
        <tag>语言原理</tag>
      </tags>
  </entry>
</search>
